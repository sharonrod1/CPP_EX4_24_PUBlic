התוכנית שלי היא אפליקציה גרפית שמציגה עץ (Tree) באמצעות Qt. העץ יכול להיות מורכב מסוגים שונים, כולל סוג Complex מותאם אישית וסוגים סטנדרטיים כמו std::string. התוכנית כוללת גם בדיקות יחידה (unit tests) באמצעות ספריית doctest כדי לוודא את נכונות המימוש.

מבנה הקוד
Node
קובץ node.hpp מגדיר מחלקה Node גנרית המייצגת צומת בעץ. כל צומת מכיל מזהה, ערך מהסוג הגנרי T, מצביע להורה, ורשימה של מצביעים לשכנים (ילדים).

Complex
קובץ complex.hpp מגדיר מחלקה Complex המייצגת מספר מרוכב, עם חלק ממשי וחלק דמיוני, ופונקציות לעבודה עם מספרים מרוכבים.

Tree
קובץ tree.hpp מגדיר מחלקה Tree גנרית המייצגת עץ. מחלקה זו כוללת פונקציות להוספת צומת שורש (root), הוספת תת-צומת (sub-node), הדפסה גרפית של העץ ובדיקה אם יש מעגלים בעץ.

איטרטורים
במחלקה Tree יש מספר איטרטורים שמאפשרים לעבור על הצמתים בעץ בדרכים שונות:

MinHeapIterator - איטרטור שמסדר את הצמתים במבנה ערימה ממוינת (min-heap). הוא עובר על הצמתים בסדר של ערך מינימלי.

IteratorPreOrder - איטרטור שעובר על הצמתים בסדר קדם-סדר (pre-order). כלומר, הוא מבקר את הצומת הנוכחי לפני שהוא מבקר את ילדיו.

IteratorPostOrder - איטרטור שעובר על הצמתים בסדר לאחר-סדר (post-order). כלומר, הוא מבקר את כל הילדים של הצומת הנוכחי לפני שהוא מבקר את הצומת עצמו.

IteratorInOrder - איטרטור שעובר על הצמתים בסדר תווך-סדר (in-order). מתאים לעצי בינארי בלבד, בו הוא מבקר את הצומת השמאלי, אחר כך את הצומת הנוכחי ולבסוף את הצומת הימני.

BfsScan - איטרטור שעובר על הצמתים בסריקת רוחב (Breadth-First Search). כלומר, הוא מבקר את כל הצמתים באותו עומק לפני שהוא מבקר את הצמתים בעומק הבא.

dfsScan - איטרטור שעובר על הצמתים בסריקת עומק (Depth-First Search). כלומר, הוא הולך עד כמה שאפשר בצד אחד של העץ לפני שהוא חוזר ועובר לצדדים האחרים.

כדי להריץ את התוכנית רושמים (make) ואז את שם הקובץ שאנחנו רוצים להריץ לדוגמא (DEMO/.)
